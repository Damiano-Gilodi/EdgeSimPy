"""Contains application-related functionality."""

# EdgeSimPy components
from dataclasses import asdict
from typing import TYPE_CHECKING
from edge_sim_py.component_manager import ComponentManager
from edge_sim_py.components.data_packet import DataPacket

# Mesa modules
from mesa import Agent  # type: ignore[import]

if TYPE_CHECKING:
    from edge_sim_py.components.user import User
    from edge_sim_py.components.service import Service


class Application(ComponentManager, Agent):
    """Class that represents an application."""

    # Class attributes that allow this class to use helper methods from the ComponentManager
    _instances: list["Application"] = []
    _object_count = 0

    def __init__(self, obj_id: int | None = None, label: str = ""):
        """Creates an Application object.

        Args:
            obj_id (int, optional): Object identifier.
            label (str, optional): Application label.

        Returns:
            object: Created Application object.
        """
        # Adding the new object to the list of instances of its class
        self.__class__._instances.append(self)

        # Object's class instance ID
        self.__class__._object_count += 1
        if obj_id is None:
            obj_id = self.__class__._object_count
        self.id = obj_id

        # Application label
        self.label = label

        # List of services that compose the application
        self.services: list["Service"] = []

        # List of users that access the application
        self.users: list["User"] = []

        # List of data packets generated by the application for each user
        self._user_data_packets: dict[str, list["DataPacket"]] = {}

        # Model-specific attributes (defined inside the model's "initialize()" method)
        self.model = None
        self.unique_id = None

    def _to_dict(self) -> dict:
        """Method that overrides the way the object is formatted to JSON."

        Returns:
            dict: JSON-friendly representation of the object as a dictionary.
        """
        dictionary = {
            "attributes": {
                "id": self.id,
                "label": self.label,
            },
            "relationships": {
                "services": [{"class": type(service).__name__, "id": service.id} for service in self.services],
                "users": [{"class": type(user).__name__, "id": user.id} for user in self.users],
            },
        }
        return dictionary

    def collect(self) -> dict:
        """Method that collects a set of metrics for the object.

        Returns:
            metrics (dict): Object metrics.
        """
        """Collects metrics for the application and its datapackets in an optimized way."""
        user_data_packets_metrics = {}

        for user_id, packets in self._user_data_packets.items():
            user_metrics = []
            for dp in packets:

                hops_serialized = [asdict(hop) for hop in dp._link_hops]
                total_path = [[network_switch.id for network_switch in hop] for hop in dp._total_path]

                dp_metrics = {
                    "Id": dp.id,
                    "User": dp.user.id,
                    "Queue Delay": dp._queue_delay_total,
                    "Transmission Delay": dp._transmission_delay_total,
                    "Processing Delay": dp._processing_delay_total,
                    "Propagation Delay": dp._propagation_delay_total,
                    "Total Delay": dp._total_delay,
                    "Total Path": total_path,
                    "Hops": hops_serialized,
                }
                user_metrics.append(dp_metrics)

            user_data_packets_metrics[user_id] = user_metrics

        metrics = {
            "Id": self.id,
            "Label": self.label,
            "Services": [service.id for service in self.services],
            "Users": [user.id for user in self.users],
            "Data packets": user_data_packets_metrics,
        }

        return metrics

    def step(self):
        """Method that executes the events involving the object at each time step."""
        ...

    def connect_to_service(self, service: "Service") -> "Application":
        """Creates a relationship between the application and a given Service object.

        Args:
            service (Service): Service object.

        Returns:
            object: Updated Application object.
        """
        self.services.append(service)
        service.application = self

        return self

    def _register_datapacket(self, user: "User", size: int) -> "DataPacket":
        """Registers a data packet generated by the application for a given user.

        Args:
            user (User): User object.
            size (int): Size of the data packet in bytes.

        Returns:
            object: Created DataPacket object.
        """
        if user not in self.users or self not in user.applications:
            raise ValueError("Connection between application users is not allowed.")

        dp = DataPacket(user=user, application=self, size=size)

        if str(user.id) not in self._user_data_packets:
            self._user_data_packets[str(user.id)] = []
        self._user_data_packets[str(user.id)].append(dp)
        return dp
